---
title: "Exploratory Data Analysis (EDA)"
author: "Ian Dinwoodie"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(janitor)
library(psych)
library(caret)
knitr::opts_chunk$set(echo=TRUE)
set.seed(1)
```

# Loading the Tidy Data

Load the tidy data from disk if it is available. If it is not available, run
`notebook-0-tidy.Rmd` to create it.

```{r}
df <- readRDS('../data/processed/tidy.Rds')
#stopifnot(identical(dim(df)+0, c(1411, 28)))
str(df)
```

A summary of the loaded data is provided below.

```{r}
summary(df)
```

# Descriptive Stats

## Owner Demographics

The number of participating owners is equal to the number of unique owner
identifiers.

```{r}
length(unique(df$owner_id))
```

Generate a breakdown of owner gender.

```{r}
df %>%
  distinct(owner_id, .keep_all=TRUE) %>%
  count(is_male) %>%
  mutate(freq = round(n / sum(n) * 100, 2)) %>%
  adorn_totals("row")
```

Generate summary statistics for owner ages.

```{r}
summary(
  df %>%
    distinct(owner_id, .keep_all=TRUE) %>%
    dplyr::select(age)
)
```

Examine the distribution of owner ages.

```{r}
df %>%
  ggplot(aes(x=age)) +
    geom_histogram(alpha=0.5, position="identity", aes(y = ..density..),
                   color="black", bins=30) +
    geom_density() +
    geom_vline(xintercept=mean(df$age), color="black", linetype="dashed",
               size=1)
```

Examine the distribution of ages split by owner gender.

```{r}
means <- df %>% filter(!is.na(is_male)) %>% group_by(is_male) %>%
  summarise(means = mean(age))
df %>%
  filter(!is.na(is_male)) %>%
  ggplot(aes(age, fill = is_male)) +
    geom_histogram(alpha=0.7, position="identity", aes(y = ..density..),
                   color="black", bins=30) +
    geom_density(alpha=0.7) +
    geom_vline(xintercept=means$means, colour = "black", linetype="dashed",
               size=0.5)
```

## Dog Demographics

The number of dogs corresponds to the number of rows in the data frame.

```{r}
dim(df)[1]
```

Generate summary statistics for the number of dogs per household.

```{r}
summary(as.data.frame(table(df$owner_id))$Freq)
```

Determine the number of single dog households.

```{r}
df %>%
  count(owner_id) %>%
  mutate(freq = n / sum(n)) %>%
  filter(n == 1) %>%
  mutate(freq = round(sum(freq) * 100, 2)) %>%
  count(freq)
```
Generate breakdown of acquisition sources.

```{r}
df %>%
  count(acquisition_source) %>%
  mutate(freq = round(n / sum(n) * 100, 2)) %>%
  adorn_totals("row")
```

Generate breakdown of living situation.

```{r}
df %>%
  count(is_living_with_dog) %>%
  mutate(freq = round(n / sum(n) * 100, 2)) %>%
  adorn_totals("row")
```

### Dogs Not-Living-With-Owner Demographics

```{r}
df %>%
  filter(is_living_with_dog == FALSE) %>%
  count(time_together_len) %>%
  mutate(freq = round(n / sum(n) * 100, 2)) %>%
  adorn_totals("row")
```

```{r}
df %>%
  filter(is_living_with_dog == FALSE) %>%
  count(curr_dog_location) %>%
  mutate(freq = round(n / sum(n) * 100, 2)) %>%
  adorn_totals("row")
```

## Expectations and Considerations

Generate breakdown for meeting of expectations.

```{r}
df %>%
  count(met_expectations) %>%
  mutate(freq = round(n / sum(n) * 100, 2)) %>%
  adorn_totals("row")
```

```{r}
df %>%
  group_by(is_satisfied) %>%
  summarise(n = n()) %>%
  mutate(freq = round(n / sum(n) * 100, 2)) %>%
  adorn_totals("row")
```

Generate breakdown for time spent thinking.

```{r}
df %>%
  count(time_thinking) %>%
  mutate(freq = round(n / sum(n) * 100, 2)) %>%
  adorn_totals("row")
```

Generate breakdown for primary motivation.

```{r}
df %>%
  count(primary_motivation) %>%
  mutate(freq = round(n / sum(n) * 100, 2)) %>%
  adorn_totals("row")
```

Generate a summary for characteristic ranks.

```{r}
df %>%
  select(contains("rank") & !contains("revised")) %>%
  summary()
```

## Consideration of Another Dog

```{r}
df %>%
  group_by(owner_id) %>%
  fill(is_consider_another_dog, .direction="downup") %>%
  ungroup() %>%
  distinct(owner_id, .keep_all=TRUE) %>%
  count(is_consider_another_dog) %>%
  mutate(freq = round(n / sum(n) * 100, 2)) %>%
  adorn_totals("row")
```

```{r}
df %>%
  group_by(revised_acquisition_source) %>%
  summarise(n = n()) %>%
  mutate(freq = round(n / sum(n) * 100, 2)) %>%
  adorn_totals("row")
```

Generate a summary for revised characteristic ranks.

```{r}
df %>%
  select(contains("rank") & contains("revised")) %>%
  summary()
```

Difference in rank between revised rank and average of prior ranks.

```{r}
df %>%
  group_by(owner_id) %>%
  select(owner_id, contains("rank")) %>%
  mutate_at(vars(-group_cols()), funs(mean(., na.rm = TRUE))) %>%
  ungroup() %>%
  distinct(owner_id, .keep_all=TRUE) %>%
  select(-owner_id) %>%
  mutate(age_delta = revised_age_rank - age_rank) %>%
  mutate(app_delta = revised_appearance_rank - appearance_rank) %>%
  mutate(breed_delta = revised_breed_rank - breed_rank) %>%
  mutate(comp_delta = revised_compatability_rank - compatability_rank) %>%
  mutate(pers_delta = revised_personality_rank - personality_rank) %>%
  mutate(size_delta = revised_size_rank - size_rank) %>%
  mutate(train_delta = revised_trainability_rank - trainability_rank) %>%
  select(contains("delta")) %>%
  summary()
```

# Data Exploration

## Numeric Correlations

```{r, fig.width=5, fig.height=4}
pairs.panels(df[,12:19])
```

## Fields Split by Met Expecations

### Owner Fields

Split by owner gender.

```{r}
df %>%
  count(is_male, is_satisfied) %>%
  spread(is_satisfied, n) %>%
  adorn_totals("row") %>%
  adorn_totals("col")
```

```{r}
df %>%
  filter(!is.na(is_male)) %>%
  group_by(is_male) %>%
  mutate(freq = sum(is_satisfied) / n()) %>%
  ggplot(aes(x=reorder(is_male, desc(freq)), fill=is_satisfied)) +
    geom_bar(position="fill") +
    xlab("owner is male") +
    ylab("frequency")
```

Split by owner age.

```{r}
means <- df %>% group_by(is_satisfied) %>% summarise(means = mean(age))
df %>%
  ggplot(aes(age, fill = is_satisfied)) +
    geom_histogram(alpha=0.7, position="identity", aes(y = ..density..),
                   color="black", bins=30) +
    geom_density(alpha=0.7) +
    geom_vline(xintercept=means$means, color="black", linetype="dashed",
               size=0.5)
```

### Dog Fields

Split by acquisition source.

```{r}
df %>%
  count(acquisition_source, is_satisfied) %>%
  spread(is_satisfied, n) %>%
  adorn_totals("row") %>%
  adorn_totals("col")
```

```{r}
df %>%
  group_by(acquisition_source) %>%
  mutate(freq = sum(is_satisfied) / n()) %>%
  mutate(
    acquisition_source = fct_recode(
      acquisition_source,
      "family/friend"="family_or_friend",
      "pet shop"="pet_shop",
      "shelter/rescue"="rescue"
    )
  ) %>%
  ggplot(aes(x=reorder(acquisition_source, desc(freq)), fill=is_satisfied)) +
    geom_bar(position="fill") +
    xlab("acquisition source") +
    ylab("frequency") +
    theme(axis.text.x = element_text(angle = 45, hjust=1))
```

Split by living situation.

```{r}
df %>%
  count(is_living_with_dog, is_satisfied) %>%
  spread(is_satisfied, n) %>%
  adorn_totals("row") %>%
  adorn_totals("col")
```

```{r}
df %>%
  group_by(is_living_with_dog) %>%
  mutate(freq = sum(is_satisfied) / n()) %>%
  ggplot(aes(x=reorder(is_living_with_dog, desc(freq)), fill=is_satisfied)) +
    geom_bar(position="fill") +
    xlab("living with dog") +
    ylab("frequency")
```

## Considerations Fields

Split by time spent thinking.

```{r}
df %>%
  count(time_thinking, is_satisfied) %>%
  spread(is_satisfied, n) %>%
  adorn_totals("row") %>%
  adorn_totals("col")
```

```{r}
df %>%
  group_by(time_thinking) %>%
  mutate(freq = sum(is_satisfied) / n()) %>%
  ggplot(aes(x=reorder(time_thinking, desc(freq)), fill=is_satisfied)) +
    geom_bar(position="fill") +
    xlab("time spent thinking") +
    ylab("frequency")
```

Split by primary motivation.

```{r}
df %>%
  count(primary_motivation, is_satisfied) %>%
  spread(is_satisfied, n) %>%
  adorn_totals("row") %>%
  adorn_totals("col")
```

```{r}
df %>%
  group_by(primary_motivation) %>%
  mutate(freq = sum(is_satisfied) / n()) %>%
  ggplot(aes(x=reorder(primary_motivation, desc(freq)), fill=is_satisfied)) +
    geom_bar(position="fill") +
    xlab("primary motivation") +
    ylab("frequency") +
    theme(axis.text.x = element_text(angle = 45, hjust=1))
```

Split by consideration of another dog.

```{r}
df %>%
  filter(!is.na(is_consider_another_dog)) %>%
  count(is_consider_another_dog, is_satisfied) %>%
  spread(is_satisfied, n) %>%
  adorn_totals("row") %>%
  adorn_totals("col")
```

```{r}
df %>%
  filter(!is.na(is_consider_another_dog)) %>%
  group_by(is_consider_another_dog) %>%
  mutate(freq = sum(is_satisfied) / n()) %>%
  ggplot(aes(x=reorder(is_consider_another_dog, desc(freq)), fill=is_satisfied)) +
    geom_bar(position="fill") +
    xlab("would consider an additional dog") +
    ylab("frequency") +
    theme(axis.text.x = element_text(angle = 45, hjust=1))
```

Split by ranks.

```{r, fig.width=5, fig.height=3}
featurePlot(
  x = df[, 13:19],
  y = factor(df$is_satisfied), 
  plot = "box", 
  ## Pass in options to bwplot() 
  scales = list(y = list(relation="free"), x = list(rot = 90)),  
  layout = c(4,2), 
  auto.key = list(columns = 2)
)
```

Split by revised ranks.

```{r, fig.width=5, fig.height=3}
featurePlot(
  x = df[, 20:26],
  y = factor(df$is_satisfied), 
  plot = "box", 
  ## Pass in options to bwplot() 
  scales = list(y = list(relation="free"), x = list(rot = 90)),  
  layout = c(4,2), 
  auto.key = list(columns = 2)
)
```

## Principal Component Analysis

```{r}
# PCA
df_pca <- df %>%
  dplyr::select(contains("age") | (contains("rank") & !contains("revised"))) %>%
  drop_na()
pc <- prcomp(df_pca, center = TRUE, scale = TRUE)
attributes(pc)
print(pc)
biplot(pc, scale = 0)
round(pc$sdev^2 / sum(pc$sdev^2), 2)
```

## Factor Analysis

```{r}
df_rank <- df[,c(13, 18:19)]
#fa_result <- factanal(df[,13:19], factors = 2)
fa(r=cor(df_rank), nfactors=dim(df_rank)[2], rotate="varimax", SMC=FALSE, fm="pa")
```

# SCRATCH BELOW THIS LINE

```{r}
library(mlogit)
data("Game", package = "mlogit")
head(Game,2)
```

```{r}
df_g <- dfidx(Game, varying = 1:12, choice = "ch", ranked = TRUE,
              idnames = c("chid", "alt"))
head(df_g)
```

```{r}
summary(mlogit(ch ~ own | hours + age, df_g, reflevel = "PC"))
```

```{r}
old_names <- colnames(df %>% select(contains("rank") & !contains("revised")))
old_names <- c(old_names, "time_thinking", "primary_motivation",
               "acquisition_source", "is_living_with_dog", "age")
new_names <- c("ch.age", "ch.appearance", "ch.breed", "ch.compatability",
               "ch.personality", "ch.size", "ch.trainability")
new_names <- c(new_names, "time", "motive", "source", "is_with_dog", "owner_age")

df2 <- df %>%
  rename_with(~ new_names, all_of(old_names)) %>%
  select(
    -contains("revised"),
    -owner_id,
    -dog_name,
    -met_expectations,
    -time_together_len,
    -curr_dog_location,
    -is_consider_another_dog,
    -is_with_dog # Linearly correlated with ch.trainability
  ) %>%
  drop_na() %>%
  relocate(is_satisfied, .before = everything()) %>%
  relocate(is_male, .after = is_satisfied) %>%
  #relocate(is_with_dog, .after=is_male) %>%
  relocate(owner_age, .after=is_male)

summary(df2)
```

```{r}
# mm <- model.matrix(is_satisfied~., df2)
# summary(mm)
# 
# # Eliminate near zero-variance variables.
# nzv_metrics <- nearZeroVar(mm, saveMetrics=TRUE)
# nzv_cnt <- sum(nzv_metrics$nzv)
# print(paste("Near zero-variance vars to eliminate:", nzv_cnt))
# if (nzv_cnt) {
#   print(colnames(mm[, nzv_metrics$nzv]))
#   mm <- mm[, !nzv_metrics$nzv]
# }
# 
# # Eliminate linearly correlated predictors.
# combo_info <- findLinearCombos(mm)
# combo_cnt <- length(combo_info$remove)
# print(paste("Linearly corr. combos vars to eliminate:", combo_cnt))
# if (combo_cnt) {
#   print(colnames(mm[, combo_info$remove]))
#   mm <- mm[, -combo_info$remove]
# }
# 
# df2_m <- cbind.data.frame(is_satisfied=df2$is_satisfied, mm)
# colnames(df2_m) <- make.names(colnames(df2_m))
# summary(df2_m)
```

```{r}
# Reference: https://bookdown.org/rehk/stm1001_dsm_introduction_to_machine_learning_in_r/machine-learning-in-r-using-the-caret-package.html
dummies <- dummyVars(is_satisfied ~ ., data = df2, fullRank = F)
df2_updated <- as_tibble(predict(dummies, newdata = df2))
df2_updated <- cbind(is_satisfied = df2$is_satisfied, df2_updated)
summary(df2_updated)
```
```{r}
# Eliminate near zero-variance variables.
nzv_metrics <- nearZeroVar(df2_updated, saveMetrics=TRUE)
nzv_cnt <- sum(nzv_metrics$nzv)
print(paste("Near zero-variance vars to eliminate:", nzv_cnt))
if (nzv_cnt) {
  print(colnames(df2_updated[, nzv_metrics$nzv]))
  df2_updated <- df2_updated[, !nzv_metrics$nzv]
}
colnames(df2_updated)
```

```{r}
# Eliminate linearly correlated predictors.
combo_info <- findLinearCombos(df2_updated)
print(combo_info)
combo_cnt <- length(combo_info$remove)
print(paste("Linearly corr. combos vars to eliminate:", combo_cnt))
if (combo_cnt) {
  print(colnames(df2_updated)[combo_info$remove])
  df2_updated <- df2_updated[, -combo_info$remove]
}
colnames(df2_updated)
```


```{r}
# We need to make the number of cols equal for each varying type. Right now we
# have: time=4, motive=8, source=7, ch=7.
#df2_updated$time.fake_5 <- NA
#df2_updated$time.fake_6 <- NA
#df2_updated$time.fake_7 <- NA
#df2_updated$time.fake_8 <- NA
#df2_updated$source.fake_8 <- NA
#df2_updated$ch.fake_8 <- NA

df2_updated <- df2_updated %>%
  dplyr::select(-is_maleFALSE) %>%
  mutate(is_satisfied = as.factor(ifelse(is_satisfied==TRUE, "yes", "no"))) %>%
  dplyr::select(is_satisfied, is_maleTRUE, owner_age, ch.age, contains("source"))

summary(df2_updated)
```

```{r}
#df2_g <- dfidx(df2_updated, varying = 4:10, choice = "ch", ranked = TRUE,
#               idnames = c("chid", "alt"))
#head(df2_g)
```

```{r}
# tm <- mlogit.data(
#   df2_updated, choice="ch", shape = "wide", sep=".", ranked=TRUE, varying = 4:10)
# head(tm)
```

```{r}
#summary(mlogit(is_satisfied ~ 1 + ch | is_maleTRUE + owner_age, data=tm, reflevel="TRUE"))
```

```{r}
set.seed(16505050)
train_index <- createDataPartition(
  df2_updated$is_satisfied,
  p = .7,
  list = FALSE, 
  times = 1
)
training <- df2_updated[train_index, ]
summary(training)
testing <- df2_updated[-train_index, ]
summary(testing)
```

```{r}
set.seed(1)
fit <- train(is_satisfied ~ .,
             data = training,
                 method = "C5.0Cost",
                 trControl = trainControl(method = "LOOCV", classProbs = TRUE,
                                          summaryFunction = twoClassSummary)
                                          #summaryFunction = prSummary)
)
fit
confusionMatrix(predict(fit, testing), testing$is_satisfied)
```

```{r}
plot(fit)
```

# Save Session Info

```{r}
sessionInfo()
```
